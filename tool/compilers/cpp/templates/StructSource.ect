arguments: const std::string &toolversion, const Argonauts::Tool::Struct &structure, const Argonauts::Tool::TypeProvider *types, const std::string &headerFilename, const StringVector &acceptedObjectKeys, const std::unordered_set<std::string> &listTypes, const std::function<std::string(const Argonauts::Tool::Type::Ptr &, const std::string &, const Argonauts::Tool::TypeProvider *)> &serializationFor
includes: "util/StringUtil.h", "tool/DataTypes.h", "tool/compilers/cpp/TypeProviders.h", <unordered_set>, <functional>

// Generated by ProjectArgonauts <%= toolversion %>. DO NOT EDIT!

#include "<%= headerFilename %>"
#include "util/SaxSink.h"
#include <Argonauts.h>

<% using namespace Argonauts::Util; %>

namespace Argonauts {
namespace Runtime {
<% for (const Argonauts::Tool::Type::Ptr &type : structure.allTypes()) { %>
	<% if (type->name == "List") { %>
		HandleParseAction handleParseArray(<%= types->fullType(type) %> &type);
	<% } else if (type->name == "Map") { %>
		HandleParseAction handleParseObject(<%= types->fullType(type) %> &type);
	<% } else if (type->isSimple() || !type->isBuiltin()) { %>
		// using built-ins for simple types or already declared for user types
	<% } else if (type->name == "Variant") { %>
		// TODO: implement variant parsing
	<% } else throw std::runtime_error("Something went horribly wrong"); %>
<% } %>
}
}

class CommonDelegatingSaxSink : public Argonauts::Util::DelegatingSaxSink
{
protected:
	bool handleParseActionResult(const Argonauts::Runtime::HandleParseAction &action)
	{
		using namespace Argonauts::Runtime;

		switch (action.action) {
		case HandleParseAction::Success: return true;
		case HandleParseAction::DelegateToArray:
			delegateToArray(action.delegationTarget);
			return true;
		case HandleParseAction::DelegateToObject:
			delegateToObject(action.delegationTarget);
			return true;
		case HandleParseAction::Error:
			reportError(action.error);
			return false;
		}
	}
};

<% for (const Argonauts::Tool::Type::Ptr &type : structure.allTypes()) { %>
	<% if (type->name == "List") { %>
		<% const Argonauts::Tool::Type::Ptr containedType = type->templateArguments.front(); %>
		class Array_<%= std::size_t(type.get()) %>_SaxSink : public CommonDelegatingSaxSink
		{
			<%= types->fullType(type) %> &m_value;
			bool m_wasStarted = false;

		public:
			explicit Array_<%= std::size_t(type.get()) %>_SaxSink(<%= types->fullType(type) %> &value) : m_value(value) {}

			bool nullImpl() override { return reportError("Unexpected value of type 'null'"); }
			bool booleanImpl(const bool val) override
			{
				<% if (containedType->name == "Bool") { %>
				m_value.push_back(val);
				return true;
				<% } else { %>
				return reportError("Unexpected value of type 'boolean'");
				<% } %>
			}
			bool integerNumberImpl(const int64_t val) override
			{
				<% if (containedType->isInteger() || containedType->name == "Double") { %>
				m_value.push_back(val);
				return true;
				<% } else { %>
				return reportError("Unexpected value of type 'integer'");
				<% } %>
			}
			bool doubleNumberImpl(const double val) override
			{
				<% if (containedType->name == "Double") { %>
				m_value.push_back(val);
				return true;
				<% } else { %>
				return reportError("Unexpected value of type 'integer'");
				<% } %>
			}
			bool stringImpl(const std::string &val) override
			{
				<% if (containedType->name == "String") { %>
				m_value.push_back(val);
				return true;
				<% } else { %>
				return reportError("Unexpected value of type 'string'");
				<% } %>
			}

			bool startObjectImpl() override
			{
				<% if (containedType->isObjectish()) { %>
				m_value.push_back(<%= types->fullType(containedType) %>());
				return handleParseActionResult(Argonauts::Runtime::handleParseObject(m_value.back()));
				<% } else { %>
				return reportError("Unexpected value of type 'object'");
				<% } %>
			}
			bool keyImpl(const std::string &key) override
			{
				return false;
			}
			bool endObjectImpl(const std::size_t) override
			{
				return true;
			}

			bool startArrayImpl() override
			{
				if (!m_wasStarted) {
					m_wasStarted = true;
					return true;
				}

				<% if (containedType->name == "List") { %>
				m_value.push_back(<%= types->fullType(containedType) %>());
				return handleParseActionResult(Argonauts::Runtime::handleParseArray(m_value.back()));
				<% } else { %>
				return reportError("Unexpected value of type 'array'");
				<% } %>
			}
			bool endArrayImpl(const std::size_t) override
			{
				return true;
			}
		};
		Argonauts::Runtime::HandleParseAction Argonauts::Runtime::handleParseArray(<%= types->fullType(type) %> &type)
		{
			return Argonauts::Runtime::HandleParseAction(Argonauts::Runtime::HandleParseAction::DelegateToArray, new Array_<%= std::size_t(type.get()) %>_SaxSink(type));
		}
	<% } else if (type->name == "Variant") { %>

	<% } else if (type->name == "Map") { %>
		<% const Argonauts::Tool::Type::Ptr valueType = type->templateArguments.at(1); %>
		class Map_<%= std::size_t(type.get()) %>_SaxSink : public CommonDelegatingSaxSink
		{
			<%= types->fullType(type) %> &m_value;
			bool m_wasStarted = false;
			std::string m_currentKey;

		public:
			explicit Map_<%= std::size_t(type.get()) %>_SaxSink(<%= types->fullType(type) %> &value) : m_value(value) {}

			bool nullImpl() override { return reportError("Unexpected value of type 'null'"); }
			bool booleanImpl(const bool val) override
			{
				<% if (valueType->name == "Bool") { %>
				m_value.insert(m_currentKey, val);
				return true;
				<% } else { %>
				return reportError("Unexpected value of type 'boolean'");
				<% } %>
			}
			bool integerNumberImpl(const int64_t val) override
			{
				<% if (valueType->isInteger() || valueType->name == "Double") { %>
				m_value.insert(m_currentKey, val);
				return true;
				<% } else { %>
				return reportError("Unexpected value of type 'integer'");
				<% } %>
			}
			bool doubleNumberImpl(const double val) override
			{
				<% if (valueType->name == "Double") { %>
				m_value.insert(m_currentKey, val);
				return true;
				<% } else { %>
				return reportError("Unexpected value of type 'integer'");
				<% } %>
			}
			bool stringImpl(const std::string &val) override
			{
				<% if (valueType->name == "String") { %>
				m_value.insert(m_currentKey, val);
				return true;
				<% } else { %>
				return reportError("Unexpected value of type 'string'");
				<% } %>
			}

			bool startObjectImpl() override
			{
				if (!m_wasStarted) {
					m_wasStarted = true;
					return true;
				}

				<% if (valueType->isObjectish()) { %>
					<%= types->fullType(valueType) %> val;
					const bool ret = handleParseActionResult(Argonauts::Runtime::handleParseObject(val));
					m_value.insert(m_currentKey, val);
					return ret;
				<% } else { %>
					return reportError("Unexpected value of type 'object'");
				<% } %>
			}
			bool keyImpl(const std::string &key) override
			{
				m_currentKey = key;
				return true;
			}
			bool endObjectImpl(const std::size_t) override
			{
				return true;
			}

			bool startArrayImpl() override
			{
				<% if (valueType->name == "List") { %>
					<%= types->fullType(valueType) %> val;
					const bool ret = handleParseActionResult(Argonauts::Runtime::handleParseArray(val));
					m_value.insert(m_currentKey, val);
					return ret;
				<% } else { %>
					return reportError("Unexpected value of type 'array'");
				<% } %>
			}
			bool endArrayImpl(const std::size_t) override
			{
				return true;
			}
		};
		Argonauts::Runtime::HandleParseAction Argonauts::Runtime::handleParseObject(<%= types->fullType(type) %> &type)
		{
			return Argonauts::Runtime::HandleParseAction(Argonauts::Runtime::HandleParseAction::DelegateToObject, new Map_<%= std::size_t(type.get()) %>_SaxSink(type));
		}
	<% } else if (!type->isBuiltin()) { %>
		// nothing, createSink gets defined by other files
	<% } else if (!type->isSimple()) throw std::runtime_error("Need to add sink for given type"); %>
<% } %>

class <%= structure.name %>SaxSink : public CommonDelegatingSaxSink
{
	<%= structure.name %> &m_val;
	std::string m_currentKey;

public:
	explicit <%= structure.name %>SaxSink(<%= structure.name %> &val) : m_val(val) {}

	bool nullImpl() override { return reportError("Unexpected value of type 'null' for '%s'", m_currentKey.c_str()); }
	bool booleanImpl(const bool val) override
	{
		(void)val; // prevent "unused parameter" warnings
		if (false) {}
		<% for (const Argonauts::Tool::Attribute &attribute : structure.members) { %>
			<% if (attribute.type->name == "Bool") { %>
				else if (m_currentKey == "<%= attribute.name %>") { m_val.m_<%= attribute.name %> = val; }
			<% } %>
		<% } %>
		else return reportError("Unexpected value of type 'boolean' for '%s'", m_currentKey.c_str());
	}
	bool integerNumberImpl(const int64_t val) override
	{
		(void)val; // prevent "unused parameter" warnings
		if (false) {}
		<% for (const Argonauts::Tool::Attribute &attribute : structure.members) { %>
			<% if (attribute.type->isInteger()) { %>
				else if (m_currentKey == "<%= attribute.name %>") { m_val.m_<%= attribute.name %> = val; }
			<% } %>
		<% } %>
		else return reportError("Unexpected value of type 'integer' for '%s'", m_currentKey.c_str());
	}
	bool doubleNumberImpl(const double val) override
	{
		(void)val; // prevent "unused parameter" warnings
		if (false) {}
		<% for (const Argonauts::Tool::Attribute &attribute : structure.members) { %>
			<% if (attribute.type->name == "Double" || attribute.type->isInteger()) { %>
				else if (m_currentKey == "<%= attribute.name %>") { m_val.m_<%= attribute.name %> = val; }
			<% } %>
		<% } %>
		else return reportError("Unexpected value of type 'double' for '%s'", m_currentKey.c_str());
	}
	bool stringImpl(const std::string &val) override
	{
		(void)val; // prevent "unused parameter" warnings
		if (false) {}
		<% for (const Argonauts::Tool::Attribute &attribute : structure.members) { %>
			<% if (attribute.type->name == "String") { %>
				else if (m_currentKey == "<%= attribute.name %>") { m_val.m_<%= attribute.name %> = val; return true; }
			<% } %>
		<% } %>
		else return reportError("Unexpected value of type 'string' for '%s'", m_currentKey.c_str());
	}

	bool startObjectImpl() override
	{
		if (false) {}
		<% for (const Argonauts::Tool::Attribute &attribute : structure.members) { %>
			<% if (attribute.type->isObjectish()) { %>
				else if (m_currentKey == "<%= attribute.name %>") { return handleParseActionResult(Argonauts::Runtime::handleParseObject(m_val.m_<%= attribute.name %>)); }
			<% } %>
		<% } %>
		else return reportError("Unexpected value of type 'object' for '%s'", m_currentKey.c_str());
	}
	bool keyImpl(const std::string &key) override
	{
		if (false) {}
		<% for (const Argonauts::Tool::Attribute &attribute : structure.members) { %>
			else if (key == "<%= attribute.name %>") { m_currentKey = key; return true; }
		<% } %>
		else return reportError("Unexpected key '%s', expected one of'<%= String::joinStrings(acceptedObjectKeys, "', '") %>", key.c_str());
	}
	bool endObjectImpl(const std::size_t) override { return true; }

	bool startArrayImpl() override
	{
		if (false) {}
		<% for (const Argonauts::Tool::Attribute &attribute : structure.members) { %>
			<% if (attribute.type->name == "List") { %>
				else if (m_currentKey == "<%= attribute.name %>") { return handleParseActionResult(Argonauts::Runtime::handleParseArray(m_val.m_<%= attribute.name %>)); }
			<% } %>
		<% } %>
		else return reportError("Unexpected value of type 'array' for '%s'", m_currentKey.c_str());
	}
	bool endArrayImpl(const std::size_t) override { return true; }
};

namespace Argonauts {
namespace Runtime {
template <> HandleParseAction handleParseObject<<%= structure.name %>>(<%= structure.name %> &val)
{
	return HandleParseAction(HandleParseAction::DelegateToObject, new <%= structure.name %>SaxSink(val));
}
}
}

void <%= structure.name %>::serialize(Argonauts::Runtime::Serializer *serializer) const
{
	serializer->emitObjectStart();
	<% for (const Argonauts::Tool::Attribute &attribute : structure.members) { %>
		serializer->emitObjectKey("<%= attribute.name %>");
		<%= serializationFor(attribute.type, std::string("m_") + attribute.name, types) %>
	<% } %>
	serializer->emitObjectEnd(<%= structure.members.size() %>);
}

void <%= structure.name %>::Builder::verify() const
{
	// TODO: verifications here
}

/*
 * Copyright 2015 Jan Dalheimer <jan@dalheimer.de>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
arguments: const std::string &toolversion, const std::string &root, const Argonauts::Tool::File &file, const Argonauts::Tool::TypeProvider *types, const std::string &enumSerialization
includes: <string>, <algorithm>, "util/StringUtil.h", "util/Error.h", "DataTypes.h", "tool/compilers/cpp/TypeProviders.h"

// Generated by ProjectArgonauts <%= toolversion %>. DO NOT EDIT!

#include "<%= root %>.serializer.json.arg.h"

<% using namespace Argonauts::Tool; %>

<% // can't use a lambda here because it can't be called recusively %>
<% struct SerializationFor {
	std::string &out;
	const TypeProvider *types;
	File file;
	explicit SerializationFor(std::string &o, const TypeProvider *t, const File &f) : out(o), types(t), file(f) {}
	void operator()(const std::string &variable, const Type::Ptr &type, const Annotations &annotations)
	{ %>

		<% if (type->name == "Variant") { %>
			if (false) {}
			<% for (std::size_t i = 0; i < type->templateArguments.size(); ++i) { %>
				<% const Type::Ptr &arg = type->templateArguments[i]; %>
				else if (<%= variable %>.is<<%= types->fullType(arg) %>>()) {
					<% if (std::find_if(file.structs.begin(), file.structs.end(), [arg](const Struct &s) { return s.name == arg->name; }) != file.structs.end()) { %>
						<% if (annotations.getString("variant.selectBy", "firstFieldAvailable") == "typeField") { %>
							serialize(<%= variable %>.get<<%= types->fullType(arg) %>>(),
								"<%= annotations.getString("variant.typeFieldName", "type") %>",
								"<%= annotations.contains("variant.typeFieldTypes") ? annotations.getStrings("variant.typeFieldTypes")[i] : arg->name.value %>"
							);
						<% } else { %>
							serialize(<%= variable %>.get<<%= types->fullType(arg) %>>());
						<% } %>
					<% } else { %>
						serialize(<%= variable %>.get<<%= types->fullType(arg) %>>());
					<% } %>
				}
			<% } %>
		<% } else if (type->name == "List") { %>
			push("[");
			bool <%= variable %>_hadFirst = false;
			for (const auto &<%= variable %>_ : <%= variable %>) {
				if (<%= variable %>_hadFirst) { push(","); }
				else { <%= variable %>_hadFirst = true; }
				<% this->operator()(variable + '_', type->templateArguments.at(0), annotations); %>
			}
			push("]");
		<% } else if (type->name == "Map") { %>
			push("{");
			bool <%= variable %>_hadFirst = false;
			for (const auto &<%= variable %>_pair : <%= variable %>) {
				if (<%= variable %>_hadFirst) { push(","); }
				else { <%= variable %>_hadFirst = true; }
				push("\"");
				push(<%= types->function("StringToStdString") %>(<%= variable %>_pair.first));
				push("\":");
				const auto <%= variable %>_ = <%= variable %>_pair.second;
				<% this->operator()(variable + '_', type->templateArguments.at(1), annotations); %>
			}
			push("}");
		<% } else { %>
			serialize(<%= variable %>);
		<% } %>
	<% }
}; %>

class <%= root %>Serializer
{
	std::function<void(const std::string &)> m_callback;
public:
	explicit <%= root %>Serializer(std::function<void(const std::string &)> &&callback)
		: m_callback(std::forward<std::function<void(const std::string &)>>(callback)) {}

	inline void push(const std::string &str)
	{
		m_callback(str);
	}

	// serializers for simple built-in types
	inline void serialize(const <%= types->type("String") %> &str) { push(std::string("\"") + <%= types->function("StringToStdString") %>(str) + "\""); }
	inline void serialize(const <%= types->type("Bool") %> val) { push(val ? "true" : "false"); }
	inline void serialize(const <%= types->type("Double") %> &val) { push(std::to_string(val)); }
<% for(const std::string &integer : Type::integers()) { %>
	inline void serialize(const <%= types->type(integer) %> &i) { push(std::to_string(i)); }
<% } %>

	// serializers for enums
<% for(const Enum &e : file.enums) { %>
	void serialize(const <%= e.name %> &data)
	{
		<% if (enumSerialization == "integer") { %>
			push(std::to_string((<%= e.type %>)data));
		<% } else if (enumSerialization == "string") { %>
			switch (data) {
			<% for (const EnumEntry &entry : e.entries) { %>
			case <%= e.name %>::<%= entry.name %>: push("\"<%= entry.name %>\""); break;
			<% } %>
			}
		<% } %>
	}
<% } %>

	// serializers for structs
<% for (const Struct &s : file.structs) { %>
	void serialize(const <%= s.name %> &data)
	{
		push("{");
		bool hadFirst = false;
		<% for (const Attribute &attr : s.members) { %>
		{
			bool output = true;
			<% if (attr.annotations.contains("optional")) { %>
				<% if (attr.annotations.isString("optional") && attr.type->name == "String") { %>
					if (data.<%= attr.name %>() == "<%= attr.annotations.getString("optional") %>") output = false;
				<% } else if (attr.type->isInteger()) { %>
					if (data.<%= attr.name %>() == <%= attr.annotations.getInt("optional") %>) output = false;
				<% } %>
			<% } %>
			if (output) {
				if (hadFirst) { push(","); }
				else { hadFirst = true; }
				push("\"<%= attr.name %>\":");
				const auto var = data.<%= attr.name %>();
				<% SerializationFor(out, types, file)("var", attr.type, attr.annotations); %>
			}
		}
		<% } %>
		push("}");
	}
<% } %>


	// serializers for type aliases
<% for (const Using &u : file.usings) { %>
	void serialize(const <%= u.name %> &data)
	{
		<% SerializationFor(out, types, file)("data", u.type, u.annotations); %>
	}
<% } %>
};

void serialize<%= root %>ToJSON(const <%= root %> &data, std::function<void(const <%= types->type("ByteArray") %>&)> &&callback)
{
	serialize<%= root %>ToJSON(data, [callback](const <%= types->type("String") %> &d) { callback(<%= types->function("StringToByteArray") %>(d)); });
}
void serialize<%= root %>ToJSON(const <%= root %> &data, std::function<void(const <%= types->type("String") %>&)> &&callback)
{
	<%= root %>Serializer([callback](const std::string &str) { callback(<%= types->function("StdStringToString") %>(str)); }).serialize(data);
}
<%= types->type("String") %> serialize<%= root %>ToJSON(const <%= root %> &data)
{
	<%= types->type("String") %> result;
	serialize<%= root %>ToJSON(data, [&result](const <%= types->type("String") %> &d) { <%= types->function("AppendToString") %>(result, d); });
	return result;
}

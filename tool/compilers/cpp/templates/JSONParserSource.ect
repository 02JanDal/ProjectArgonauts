/*
 * Copyright 2015 Jan Dalheimer <jan@dalheimer.de>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
arguments: const std::string &toolversion, const std::string &root, const Argonauts::Tool::File &file, const Argonauts::Tool::TypeProvider *types
includes: <string>, "DataTypes.h", "tool/compilers/cpp/TypeProviders.h"

// Generated by ProjectArgonauts <%= toolversion %>. DO NOT EDIT!

#include "<%= root %>.parser.json.arg.h"
#include "Argonauts.h"

#include <memory>

using namespace Argonauts::Runtime;

class <%= root %>Parser : public Parser<<%= root %>, <%= types->type("String") %>>
{
	<%= root %>::Builder m_builder;
public:
	<%= root %> result() const override { return m_builder.build(); }

	<% if (types->type("String") == "std::string") { %>
	void parse(const std::string &data) override
	<% } else { %>
	void parse(const <%= types->type("String") %> &data) override { parse(<%= types->function("StringToStdString") %>(data)); }
	inline void parse(const std::string &data) // only accessed from the overload on the previous line, so can be inline
	<% } %>
	{
		// data will always be an std::string here
	}

	void end() override
	{
	}
};

Parser<<%= root %>, <%= types->type("String") %>> *createParserFor<%= root %>FromJSON()
{
	return new <%= root %>Parser;
}
<%= root %> parse<%= root %>FromJSON(const <%= types->type("ByteArray") %> &data)
{
	return parse<%= root %>FromJSON(<%= types->function("ByteArrayToString") %>(data));
}
<%= root %> parse<%= root %>FromJSON(const <%= types->type("String") %> &data)
{
	std::unique_ptr<<%= root %>Parser> parser = std::unique_ptr<<%= root %>Parser>(new <%= root %>Parser);
	parser->parse(<%= types->function("StringToNative") %>(data));
	parser->end();
	return parser->result();
}
